<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="easy.css">
</head>
<style>
    body {
        background-color: #ccc;
    }

    .wjx {
        position: relative;
        width: 0;
        border-top: 0px solid red;
        border-right: 30px solid transparent;
        border-bottom: 60px solid red;
        border-left: 30px solid transparent;
        margin: 100px auto;
        display: block;
    }

    .wjx::before {
        content: '';
        border-top: 0px solid red;
        border-right: 90px solid transparent;
        border-bottom: 60px solid red;
        border-left: 90px solid transparent;
        top: 50px;
        left: -90px;
        transform: rotate(35deg);
        position: absolute;
        display: block;
    }

    .wjx::after {
        content: '';
        border-top: 0px solid red;
        border-right: 90px solid transparent;
        border-bottom: 60px solid red;
        border-left: 90px solid transparent;
        top: 50px;
        right: -90px;
        transform: rotate(-35deg);
        position: absolute;
        display: block;
    }

    .lbx {
        margin: 100px auto;
        width: 0;
        border-top: 0px solid red;
        border-right: 45px solid transparent;
        border-bottom: 90px solid red;
        border-left: 45px solid transparent;
        position: relative;
    }

    .lbx::after {
        content: '';
        border-top: 0px solid red;
        border-right: 45px solid transparent;
        border-bottom: 90px solid red;
        border-left: 45px solid transparent;
        position: absolute;
        transform: rotate(180deg);
        top: 30px;
        left: -45px;
    }

    .wbx {
        position: relative;
        width: 50px;
        height: 40px;
        border-top: 50px solid red;
        border-right: 30px solid transparent;
        /* border-bottom:50px solid transparent ; */
        border-left: 30px solid transparent;
        margin: 0 auto;
    }

    .wbx::before {
        content: '';
        border-right: 55px solid transparent;
        border-bottom: 40px solid red;
        border-left: 55px solid transparent;
        position: absolute;
        top: -90px;
        left: -30px;
    }

    .lbx2 {
        width: 80px;
        height: 50px;
        background-color: red;
        position: relative;
        margin: 0 auto;
    }

    .lbx2::before {
        content: '';
        position: absolute;
        border-right: 40px solid transparent;
        border-bottom: 20px solid red;
        border-left: 40px solid transparent;
        bottom: 50px;
        left: 0;
    }

    .lbx2::after {
        content: '';
        position: absolute;
        border-right: 40px solid transparent;
        border-top: 20px solid red;
        border-left: 40px solid transparent;
        top: 50px;
        left: 0;
    }

    .xx {
        margin: 50px auto;
        width: 60px;
        height: 90px;
        background-color: red;
        border-radius: 60px 60px 0 0;
        position: relative;
        transform: rotate(-45deg);
    }

    .xx::before {
        content: '';
        height: 90px;
        width: 60px;
        background-color: red;
        border-radius: 60px 60px 0 0;
        position: absolute;
        top: 16px;
        left: 16px;
        transform: rotate(90deg);
    }

    .xx1 {
        width: 100px;
        height: 100px;
        /* background-color: yellow; */
        background-image: radial-gradient(yellow 50%, green 100%);
        margin: 0 auto;
        position: relative;
        display: block;
    }

    .xx1::before {
        display: block;
        content: '';
        width: 60px;
        height: 100px;
        background-color: blue;
        position: absolute;
        border-radius: 50px 50px 0px 0;
        transform-origin: 0 100%;
        transform: rotate(-45deg);
        left: 50px;
    }

    .xx1::after {
        display: block;
        content: '';
        width: 60px;
        height: 100px;
        background-color: red;
        position: absolute;
        border-radius: 50px 50px 0px 0;
        transform-origin: 100% 100%;
        transform: rotate(45deg);
        left: -10px;
    }

    .egg {
        margin: 10px auto;
        width: 100px;
        height: 120px;
        background-image: repeating-linear-gradient(to bottom, yellow 20%, orange 40%);
        border-radius: 50% 50% 50% 50%/ 50% 50% 40% 40%;
    }

    .tj {
        margin: 0 auto;
        width: 0;
        border-top: 100px solid black;
        border-right: 100px solid white;
        border-left: 100px solid black;
        border-bottom: 100px solid white;
        border-radius: 50%;
        transform: rotate(-45deg);
        position: relative;
    }

    .tj::before {
        content: '';
        width: 0;
        border: 30px solid black;
        background-color: white;
        padding: 20px;
        border-radius: 50%;
        position: absolute;
        right: -15px;
        bottom: -85px;
    }

    .tj::after {
        content: '';
        width: 0;
        padding: 20px;
        background-color: black;
        border: 30px solid white;
        padding: 20px;
        border-radius: 50%;
        position: absolute;
        right: -85px;
        top: -85px;
    }

    .tj1 {
        margin: 50px auto;
        width: 100px;
        height: 200px;
        border-left: 100px solid white;
        background-color: black;
        border-radius: 50%;
        position: relative;
    }

    .tj1::before {
        content: '';
        width: 40px;
        height: 40px;
        border: 30px solid black;
        border-radius: 50%;
        background-color: white;
        position: absolute;
        left: -50px;
    }

    .tj1::after {
        content: '';
        width: 40px;
        height: 40px;
        border: 30px solid white;
        border-radius: 50%;
        background-color: black;
        position: absolute;
        bottom: 0;
        left: -50px
    }

    .circle {
        opacity: .5;
        margin: 50px auto;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: transparent;
        border: 1px solid red;
        box-shadow: 0px 0px 5px 5px red, 0px 0px 5px 10px yellow, 0px 0px 5px 15px green, 0px 0px 5px 20px orange;
    }

    .rad {
        float: left;
        width: 60px;
        height: 60px;
        background-image: radial-gradient(20px circle at left top, yellow, blue);
    }

    .rad1 {
        margin-left: 5px;
        float: left;
        width: 60px;
        height: 60px;
        background-image: radial-gradient(20px 40px ellipse at center, yellow, blue, red);
    }

    .dh {
        clear: both;
        margin: 0 auto;
        width: 80px;
    }

    .dh>div:nth-child(2) {
        animation-delay: -1.1s;
    }

    .dh>div:nth-child(3) {
        animation-delay: -1s;
    }

    .dh>div:nth-child(4) {
        animation-delay: -.9s;
    }

    .dh>div:nth-child(5) {
        animation-delay: -.8s;
    }

    .dh>div {
        height: 50px;
        width: 10px;
        background-color: aqua;
        display: inline-block;
        animation: loading 1.2s ease-in-out infinite;
    }

    @keyframes loading {

        0%,
        40%,
        100% {
            transform: scaleY(0.5);
        }

        20% {
            transform: scaleY(1);
        }
    }

    .dh2 {
        clear: both;
        margin: 0 auto;
        width: 80px;
    }

    .dh2>div {
        height: 20px;
        width: 10px;
        background-color: aqua;
        display: inline-block;
        animation: loading2 1.2s ease-in-out infinite;
    }

    .dh2>div:nth-child(2) {
        animation-delay: 0.1s;
    }

    .dh2>div:nth-child(3) {
        animation-delay: 0.2s;
    }

    .dh2>div:nth-child(4) {
        animation-delay: 0.3s;
    }

    .dh2>div:nth-child(5) {
        animation-delay: 0.4s;
    }

    @keyframes loading2 {

        0%,
        40%,
        100% {
            transform: scaleY(1);
        }

        20% {
            transform: scaleY(2);
        }
    }

    .load2 {
        margin: 20px auto;
        position: relative;
        width: 60px;
        height: 60px;
    }

    .load2>div {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: aqua;
        position: absolute;
        top: 0;
        left: 0;
        animation: bx .8s infinite ease-in-out;
    }

    .load2>div:last-child {
        opacity: 0.6;
        animation-delay: -.4s;
    }

    @keyframes bx {

        0%,
        100% {
            transform: scale(0);
        }

        50% {
            transform: scale(1);
        }
    }

    .text {
        border: 1px solid red;
        width: 80px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        text-shadow: 1px 1px 1px rgba(255, 255, 255, 0.623), 1px 1px 2px rgba(255, 255, 0, 0.733);
        /* white-space: normal; */
    }

    * {
        padding: 0;
        margin: 0;
        list-style: none;
    }

    #checkTest>ul>li {
        display: inline;
    }

    /* #checkTest>div:last-child>button{
        width: 40px;
        text-align: center;
        cursor: pointer;
    } */
    table {
        border-spacing: 0;
        margin: 10px auto;
        text-align: center;
    }

    table td {
        padding: 5px;
    }

    #memberForm {
        text-align: center;
    }

    tr>td:last-child {
        font-style: italic;
        color: blue;
        text-decoration: underline;
        cursor: pointer;
    }

    #memberForm>input {
        padding: 2px;
        margin: 5px 0;
    }
    #box{
        width: 100px;
        height: 100px;
        background-color: white;
        margin: 10px;
        display: flex;
        justify-content: space-between;
    }
    #box>div{
        width: 10px;
        height: 10px;
        background-color: black;
    }
    #box>div:last-child{
        align-self: flex-end;
    }
</style>

<body>
    <div class="wjx"></div>
    <div class="lbx"></div>
    <div class="wbx"></div>
    <div class="lbx2"></div>
    <div class="xx"></div>
    <div class="xx1"></div>
    <div class="egg"></div>
    <div class="tj"></div>
    <div class="tj1"></div>
    <div class="circle"></div>
    <div class="rad"></div>
    <div class="rad1"></div>
    <div class="dh">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
    <div class="dh2">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
    <div class="load2">
        <div></div>
        <div></div>
    </div>
    <div class="text">
        哒哒哒哒哒哒多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多多
    </div>
    <form id="checkTest" method="POST" action="">
        你最爱的运动？ <input type="checkbox" id="checkAll">全选
        <ul>
            <li><input type="checkbox">足球</li>
            <li><input type="checkbox">篮球</li>
            <li><input type="checkbox">跑步</li>
            <li><input type="checkbox">游泳</li>
        </ul>
        <div>
            <button id="bt1" type="button">全选</button>
            <button id="bt2" type="button">全不选</button>
            <button id="bt3" type="button">反选</button>
            <button id="bt4" type="button">提交</button>
        </div>
    </form>

    <div>
        <table border="1" id="memberTable">
            <tr>
                <td>name</td>
                <td>email</td>
                <td>salary</td>
                <td></td>
            </tr>
            <tr>
                <td>tom</td>
                <td>tom@tom.com</td>
                <td>5000</td>
                <td>delect</td>
            </tr>
            <tr>
                <td>tom</td>
                <td>tom@tom.com</td>
                <td>5000</td>
                <td>delect</td>
            </tr>
            <tr>
                <td>tom</td>
                <td>tom@tom.com</td>
                <td>5000</td>
                <td>delect</td>
            </tr>

        </table>
        <form id="memberForm">
            <div>
                姓名 <input type="text" name="" id="">
            </div>
            <div>
                邮箱 <input type="text" name="" id="">
            </div>
            <div>
                工资 <input type="text" name="" id="">
            </div>
            <input type="button" name="" id="" value="submit">
        </form>
    </div>
    <div id="box"> 
        <div></div>
        <div></div>
    </div>
</body>
<script>
    //clientHeight 不包括border 水平滚动条 margin，offsetHeight包括border 水平滚动条 margin， scrollHeight全部高度包括margin
    //scrolltop 顶到元素内容区域（不包括元素的border）offsetTop元素顶部到最近父级元素顶部的距离

    //&&执行的时候遇到返回false的条件就停下，没有返回最后一个,||遇到true就停下
    //call、apply通常是为了改变this对象 将this指定为被调用函数
    //getComputedStyle(对象，null)[name属性比如width]/对象.currentStyle[name] 兼容性
    //onscroll滚动条滚动事件/onMouse|Down|Up|Move鼠标移动事件最好给document绑定&up事件里最好把moveup事件取消=null 另外style返回值会带px clientHeight/scrollTop等不带px offsetLeft获取偏移值（向上寻找该元素第一个带position不是默认值的元素计算偏移）
    //拖拽计算偏移 鼠标.clentX - 元素.offsetLeft  ,  鼠标.clentY - 元素.offsetTop
    //事件委派event.target返回触发的对象 （冒泡是后代元素触发，父级元素相同事件也会被触发），cancelBubble取消冒泡=true
    //addEventListener（事件去on,回调函数，false里到外触发/true是否捕获阶段触发 外到里触发）this绑定对象、attachEvent添加回调函数this是window 兼容性
    //setCaptrue()把页面其他的事件捕获到自己身上触发 只触发一次。releaseCaptrue()释放捕获 *适用于ie
    //onmousewheel鼠标滚轮滚动事件 addEventListener里用DOMMouseScroll
    //event.wheelDelta(火狐不支持)判断滚轮上正下负 不看值 ,event.detail只支持火狐
    //使用addEventListener()绑定函数，取消浏览器默认行为可以用 return false ,也可以 event.preventDefault(),但ie8不支持prev……
    //onkeyup松开onkeydown按下可以通过event.keyCode判断哪个按键按下，也可以通过altKey ctrlKey shiftKey判断同时按下 返回true和false
    //onkeydown可以控制input输入内容 return false可以阻止用户输入
    // 拖拽窗口实现
    // 贪吃蛇实现(定时器控制速度，封装方法)
    // 134集



    //table
    //增加member
    // var addDom = document.querySelector("input[type=button]");
    // addDom.onclick = function () {
    //     var inputVal = document.querySelectorAll("#memberForm input[type=text]");
    //     var tr = document.createElement("tr");
    //     tr.innerHTML = `<td>${inputVal[0].value}</td><td>${inputVal[1].value}</td><td>${inputVal[2].value}</td><td>delect</td>`
    //     tr.querySelector("td:last-child").onclick = delTd;
    //     var table = document.getElementById("memberTable");
    //     //table.tBodies[0].appendChild(tr);
    //     table.getElementsByTagName("tbody")[0].appendChild(tr);
    // }
    // var trDoms = document.querySelectorAll("tr>td:last-child");
    // for (var i = 1; i < trDoms.length; i++) {
    //     trDoms[i].onclick = delTd;
    // }
    // //删除
    // function delTd() {
    //     this.parentNode.parentNode.removeChild(this.parentNode);
    // }
    // //checkbox
    // function checkPar(id, fun) {
    //     var checkList = window.checkList = document.getElementsByTagName("ul")[0].getElementsByTagName("input");
    //     var checkboxDom = document.getElementById(id);
    //     checkboxDom.onclick = fun;
    // }
    // //全选框
    // checkPar("checkAll", function () {

    //     for (var i = 0; i < checkList.length; i++) {
    //         checkList[i].checked = this.checked;
    //     }
    // })
    // //全选按钮
    // checkPar("bt1", function () {
    //     for (var i = 0; i < checkList.length; i++) {
    //         checkList[i].checked = true;
    //     }
    // })
    // //全不选
    // checkPar("bt2", function () {
    //     for (var i = 0; i < checkList.length; i++) {
    //         checkList[i].checked = false;
    //     }
    // })
    // //反选
    // checkPar("bt3", function () {
    //     for (var i = 0; i < checkList.length; i++) {
    //         checkList[i].checked = !checkList[i].checked;
    //     }
    // })
    // //输出
    // checkPar("bt4", function () {
    //     for (var i = 0; i < checkList.length; i++) {
    //         checkList[i].checked ? alert(checkList[i].parentNode.lastChild.nodeValue) : ""
    //     }
    // })
    // //监听
    // var items = document.querySelectorAll("li input");
    // var checkAll = document.querySelector("#checkAll");
    // for (var i = 0; i < items.length; i++) {
    //     // console.log(items[i].checked)
    //     items[i].onclick = function () {
    //         //console.log(this.checked)
    //         checkAll.checked = true;
    //         for (var j = 0; j < items.length; j++) {
    //             if (!items[j].checked) {
    //                 checkAll.checked = false;
    //                 break;
    //             }
    //         }
    //     }
    // }
    // document.write(NaN + "");
    // document.write(Number(Infinity) + 1);
    // document.write(Number(Infinity));
    // document.write(Boolean(null));
    // document.write(null / 1);
    // document.write(`<br>${"312312" < +"5"}`);
    // document.write(`<br>${true == "1"}`);
    // document.write(`<br>${false == "0"}`);
    // document.write(`<br>${null == true || null == false && true}<br>`);
    // var n1 = 10, n2 = 20;
    // var n = n1++;
    // console.log(n)//10
    // console.log(n1)//11
    // n = ++n1;
    // console.log(n)//12
    // console.log(n1)//12
    // n = n2--;
    // console.log(n)//20
    // console.log(n2)//19
    // n = --n2;
    // console.log(n)//18
    // console.log(n2)//18
    // let a;
    // a = 10;
    // a = ++a + a++ + a;
    // document.write(a);// 10 + 12 + 12 =34
    //var a=b=c=1;
    //document.write(a,b,c);// 10 + 12 + 12 =34

    // var result= prompt('小明成绩为','');
    // result>99?alert('bmw'):result>79?alert('iphone'):result>59?alert('参考书'):'';
    // var numData=["a","b","c"];
    // var i=0;
    // for(;i<3;){
    //     numData[i] = +prompt(`第${i+1}个num`,'')
    //     ++i
    // }
    // var aa=numData[0],bb=numData[1],cc=numData[2];
    // alert (aa>bb?aa>cc?bb>cc?`${aa}>${bb}>${cc}`:`${aa}>${cc}>${bb}`:`${cc}>${aa}>${bb}`: bb>cc ? cc>aa ? `${bb}>${cc}>${aa}`:`${bb}>${aa}>${cc}`:`${cc}>${bb}>${aa}`)
    // window.onkeydown = button;
    // var result=prompt('成绩',)
    // switch(result){
    //     case result>59:
    //         alert('合格')
    //         break;
    //     default :
    //     alert('不合格')
    // }
    // var money=1000,i=0;
    // while(money<5000){
    //     money*=1.05;
    //     i++
    //     console.log(i,money)
    // }
    // var result=0;
    //     for(var i=0;i<100;i++){
    //         if(i%2==1){
    //             result+=i;
    //         }
    //     }
    //     console.log(result)
    //     var sum=0,count=0;
    // for(var i=0;i<100;i++){
    //     if(i%7==0){
    //         sum+=i;
    //         count++
    //     }
    // }
    // console.log(sum,count)
    // for(var i=100;i<1000;i++){
    //     let bai=parseInt(i/100);
    //     let shi=parseInt((i-bai*100)/10);
    //     let ge=i%10;
    //     if(bai*bai*bai+shi*shi*shi+ge*ge*ge==i){
    //         console.log(i)
    //     }
    // }
    // var num = +prompt('输入数字', '');
    // zs();
    // function zs() {
    //     for (var i = 2; i < num; i++) {
    //         if (num % i == 0) {
    //             alert('这不是一个质数')
    //             return;
    //         }
    //     }
    //     alert("这是一个质数");
    // }
    // var count=9;
    // for ( var num=1;num<count;num++) {
    //     for (var i = 0; i < num; i++) {
    //         i == num-1 ? document.write('*' + '<br />') : document.write('*');
    //     }
    // }
    //     var count=10;
    // for(;count>0;count--){
    //     for (var i = 0; i < count; i++) {
    //         document.write('*');
    //     }
    //     document.write('<br />') 
    // }
    // for(var i=0;i<10;i++){
    //     for(var j=1;j<=i;j++){
    //         document.write(`${j}*${i}=${i*j} &nbsp;`)
    //     }
    //     document.write('<br/>')
    // }
    // console.time("test")
    // for(var i=2;i<100;i++){
    //     let flag=true;
    //     for(var j=2;j<=Math.sqrt(i);j++){
    //         if(i%j==0){
    //             // alert('这不是一个质数');
    //             flag=!flag
    //             break;
    //         }
    //     }
    //     flag?document.write(i+'&nbsp;'):''
    // }
    // console.timeEnd("test")
    // function Person(name,gender,age) { 
    //     this.name=name;
    //     this.gender=gender;
    //     this.age=age;
    //  }
    //  Person.prototype.toString=function () {
    //      return "Person[name="+this.name+",gender="+this.gender+",age="+this.age+"]";
    //    }
    // var per1=new Person('孙悟空','男','18');
    // var per2=new Person('猪八戒','男','16');
    // var per3=new Person('沙和尚','男','22');
    // var per4=new Person('唐僧','男','23');
    // var per5=new Person('蜘蛛精','女','14');
    // arr=[per1,per2,per3,per4,per5];

    // function getAdult(arr) {
    //     var newArr=new Array();
    //     for(var i=0;i<arr.length;i++){
    //         if(arr[i].age>=18){
    //             newArr.push(arr[i]);
    //         }
    //     }
    //     console.log(newArr)
    //   }
    //   getAdult(arr);
    // var arr=[1,2,3,2,2,2,1,3,4,2,5];
    // arr.forEach(function (value,index,obj) {
    //     var count=0;
    //     arr.forEach(function (v,i,o) {
    //         value==v?count++:'';
    //         value==v&&count>1?o.splice(i,1):""
    //       })
    // });
    // console.log(arr)
    // function A() {  }
    // function B(a) {this.a=a;  }
    // function C(a) { if(a){this.a=a;} }
    // A.prototype.a=1;
    // B.prototype.a=1;
    // C.prototype.a=1;
    // function fn(){
    //     console.log( arguments );
    // }
    // fn(1,2,3)
    // var str="12345678";
    // var result=str.slice(1,-1);
    // console.log(result)
    // var reg=new RegExp("^\\w+\.?\\w+@[A-z0-9]+(\.[A-z]{2,5})+$","gi");
    // var reg1=/^\w+\.?\w+@[A-z0-9]+(\.[A-z]{2,5})+$/gi
    // var par=prompt('邮箱')
    // //par2=par.replace(/\s/g,"")
    // par2=par.replace(/^\s+|\s+$/g,"")
    // par3=par.match(/@/)
    // par4=par.search(/@/)
    // var result=reg.test(par);
    // console.log(result,par2,par3[0],par4)
    // var time1 = new Date();
    // var time2 = time1.getTime();
    // var time3 = new Date(time2).getFullYear() + "年" + new Date(time2).getMonth() + "月" + new Date(time2).getDate() + "日";
    // console.log(time1, time2, time3)
    // var a=1e3
    // a=a.toString(36)
    // alert( Math.max(1,2))
    //toFixed（2）保留位数四舍五入 Math.floor 向下取整 Math.ceil向上取整 Math.round(四舍五入) Math.trunc直接取整
    // var isNumber=/^[0-9]*$/g
    // console.log(isNumber.test(12))
    // function readNumber() {
    //    let num;
    // //    do{
    // //     num=prompt('输入数字')
    // //    }while(!isFinite(num))
    // num=prompt('输入数字')
    //    var repS=/^\s+|\s+$/g//去除前后空格
    //    var repS1=/\s+/g//去除所有空格
    //    num=num.replace(repS,"")
    //    if(num==null||num==="") return null
    //    return num;
    //   }
    //   alert('('+readNumber()+")")
    // function randomInteger(n,m) {
    //     return n+ Math.round(Math.random()*(m-n))
    // }
    // alert(randomInteger(1,5) )
    // function ucFirst(n) {
    //     var fStr=n.substr(0,1).toUpperCase();
    //     var EStr=n.substring(1).toLowerCase();
    //     return fStr+EStr;
    // }   
    // function ucFirst1(n) {
    //     n=n[0].toUpperCase()+n.slice(1).toLowerCase();
    //     return n;
    // }   
    // alert(ucFirst("john"))
    // alert(ucFirst1("john"))
    // function checkSpam(str) { 
    //     var reg=/viagra|XXX/gi
    //     // console.log(reg.test(str))
    //     return reg.test(str)
    //  }
    //  function checkSpam1(str) { 
    //     var str=str.toLowerCase();

    //         return str.includes('viagra')||str.includes('xxx');


    //  }
    // alert(checkSpam1('buy ViAgRA now') );
    // alert(checkSpam1('free xxxxx'))
    // alert(checkSpam1("innocent rabbit"))
    // function truncate(str, maxlength) {
    //     console.log(str.slice(0,maxlength),str.substring(0,maxlength))
    //    return str.length>maxlength?
    //    str.substr(0,maxlength-1)+'…':str
    // }
    // alert(truncate("What I'd like to tell on this topic is:", 20) )
    // alert(truncate("Hi everyone!", 20))
    // function extractCurrencyValue(str) {
    //     // return str.match(/[0-9]+/g);
    //     return str.slice(str.indexOf('$')+1)
    // }
    // alert( extractCurrencyValue('$120'));
/*     创建一个数组 styles，里面存储有 “Jazz” 和 “Blues”。
        将 “Rock-n-Roll” 从数组末端添加进去。
        用 “Classics” 替换掉数组最中间的元素。查找数组最中间的元素的代码应该适用于任何奇数长度的数组。
        去掉数组的第一个值并显示它。
        在数组前面添加 Rap 和 Reggae。 */
        /* var styles=["Jazz","Blues"]
        console.log(styles)
        styles.push("Rock-n-Roll")
        console.log(styles)
        styles[Math.round(styles.length/2)-1]="Classics"
        // styles[Math.floor((styles.length - 1) / 2)] = "Classics";
        console.log(styles)
        alert(styles.shift())
        styles.unshift("Rap","Reggae")
        console.log(styles) */
 /* 写出函数 sumInput()，要求如下：
    使用 prompt 向用户索要值，并存在数组中。
    当用户输入了非数字、空字符串或者点击“取消”按钮的时候，问询结束。
    计算并返回数组所有项之和。
    P.S. 0 是有效的数字，不要因为是 0 就停止问询。 */
    // var reg=/^[0-9]+$/
    // var array=[]
    // function sumInput(){
    //     var num = prompt('输入数字')
    //     reg.test(num)&&(function(){
    //         array.push(num)
    //         return sumInput()
    //         })()
    //         var result=0;
    //         for(number of array){
    //             result+=+number
    //         }
    // return result;
    
    // }
    // function sumInput() { 
    //     let numbers=[]
    //     // while(true){
    //     //     let value=prompt('输入数字')
    //     //     console.log(value)
    //     //     if(value===""||value===null||!isFinite(value)) break
    //     //     numbers.push(+value)
    //     // }
    //     for(;true;){
    //         let value=prompt('输入数字')
    //         console.log(value)
    //         if(value===""||value===null||!isFinite(value)) break
    //         numbers.push(+value)
    //     }
    //     let sum=0
    //     for(let number of numbers){
    //         sum+=number
    //     }
    //     return sum
    //  }
    // alert(sumInput())
 /*    输入是以数字组成的数组，例如 arr = [1, -2, 3, 4, -9, 6].

        任务是：找出所有项的和最大的 arr 数组的连续子数组。

        写出函数 getMaxSubSum(arr)，用其找出并返回最大和。 */
        // function getMaxSubSum(arr) {
        //     // var str=arr.toString();
        //     // var array=str.match(/[0-9+]/g)
        //     // var array=str.split(',')
        // //    console.log(str,array,Math.max(str))
        // var arrArray=[]
        // var length=arr.length;
        //     for(let i=0;i<length;i++){
        //         arr[i]>0 && (function(i){
        //             arrArray.push(arr[i])   //找到正值再放入数组
                    
        //             for(let j=i+1;j<length;j++){   //循环正值之后的
        //                 arrArray.push(arrArray[arrArray.length-1]+arr[j])  //放入（数组最后一个值（找到的值或正值与后面值得和）和正值之后一个值的和）
        //             }
        //         })(i)
        //     }
        // //    var result= Math.max(...arrArray)//es6语法...将一个数组转为用逗号分隔的参数序列。

        // var result= arrArray.length>0?Math.max.apply(null,arrArray):0//apply接受数组--实际等于遍历数组执行方法，call只接受参数
        //     return result;
        //   }
        // function getMaxSubSum(arr) { 
        //     var maxSum=0,partSum=0
        //     for(val of arr){
        //         partSum+=val //累加的值
        //         maxSum=Math.max(partSum,maxSum) //比较累加值与当前最大累加值
        //         if(partSum<0) partSum=0//当累加值低于0时重新累加
        //     }
        //    return maxSum>0?maxSum:0
        //  }
          
        // console.log(   getMaxSubSum([-1, 2, 3, -9]) )
        // console.log(   getMaxSubSum([2, -1, 2, 3, -9]))
        // console.log(   getMaxSubSum([-1, 2, 3, -9, 11]))
        // console.log(   getMaxSubSum([-2, -1, 1, 2]))
        // console.log(   getMaxSubSum([100, -9, 2, -3, 5]))
        // console.log(   getMaxSubSum([1, 2, 3]) )
/*         编写函数 camelize(str) 将诸如 “my-short-string” 之类的由短划线分隔的单词变成骆驼式的 “myShortString”。
            即：删除所有短横线，并将短横线后的每一个单词的首字母变为大写。 */
        //     function camelize(str){
        //         // var arr=str.split('-')
        //         // var newVal=""
                
        //         // for(val of arr){
        //         // if(val!=""){
        //         //     newVal+=val[0].toUpperCase()+val.slice(1).toLowerCase()
        //         //  }
        //         // }
        //         // newVal=newVal[0].toLowerCase()+newVal.slice(1)
        //         // return newVal
        //         return str
        //         .split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
        //         .map(
        //         // capitalizes first letters of all array items except the first one
        //         // converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
        //         // (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
        //          function (word, index) {  
        //           return index == 0 ? word : word[0].toUpperCase() + word.slice(1)
        //             // console.log(word)
                    
        //          }
        //         )
        //         .join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
        //     }
        //    console.log(camelize("background-color") )
        //    console.log(camelize("list-style-image") )
        //    console.log(camelize("-webkit-transition") )
 /*        写一个函数 filterRange(arr, a, b)，该函数获取一个数组 arr，在其中查找数值大于或等于 a，且小于或等于 b 的元素，并将结果以数组的形式返回。
        该函数不应该修改原数组。它应该返回新的数组。 */
        // function filterRange(arr, a, b){
        //     // var newArr=[]
        //     // for(val of arr){
        //     //     if(val>=a&&val<=b) newArr.push(val)
        //     // }
        //     // return newArr;
        //     return arr.filter((item=> item>=a&&item<=b))
        // }
        // let arr = [5, 3, 8, 1];
        // let filtered = filterRange(arr, 1, 4);
        // alert( filtered ); // 3,1（匹配值）
        // alert( arr ); // 5,3,8,1（未修改）
/*         写一个函数 filterRangeInPlace(arr, a, b)，该函数获取一个数组 arr，并删除其中介于 a 和 b 区间以外的所有值。检查：a ≤ arr[i] ≤ b。
            该函数应该只修改数组。它不应该返回任何东西。
            例如： */
            // function filterRangeInPlace(arr, a, b){
            //       for(i in arr){
            //           if(arr[i]<a||arr[i]>b) arr.splice(i,1)
            //       }
            // }
            // let arr = [5, 3, 8, 1];
            // filterRangeInPlace(arr, 1, 4); // 删除了范围在 1 到 4 之外的所有值
            // alert( arr ); // [3, 1]
            // let arr = [5, 2, 1, -10, 8];

            // // ……你的代码以降序对其进行排序
            // arr.sort((a,b)=>b-a)

            // alert( arr ); // 8, 5, 2, 1, -10
            /* 我们有一个字符串数组 arr。我们希望有一个排序过的副本，但保持 arr 不变。
            创建一个函数 copySorted(arr) 返回这样一个副本。 */
            // function copySorted(arr){
            //     return arr.slice().sort()
            // }
            // let arr = ["HTML", "JavaScript", "CSS"];
            // let sorted = copySorted(arr);
            // alert( sorted ); // CSS, HTML, JavaScript
            // alert( arr ); // HTML, JavaScript, CSS (no changes)
            /* 创建一个构造函数 Calculator，以创建“可扩展”的 calculator 对象。

            该任务由两部分组成。
            首先，实现 calculate(str) 方法，该方法接受像 "1 + 2" 这样格式为“数字 运算符 数字”（以空格分隔）的字符串，并返回结果。该方法需要能够理解加号 + 和减号 -。
            */
            // function Calculator(str){
            //    this.methods={
            //        "+":(a,b)=>a+b,
            //        "-":(a,b)=>a-b
            //    }
            //    this.calculate=function (str){
            //         var strArr=str.split(" ")
            //         var s=+strArr[0]
            //         var t=strArr[1]
            //         var r=+strArr[2]
            //         if(!this.methods[t]||isNaN(s)||isNaN(r)) return NaN
            //         return this.methods[t](s,r)
            //    }
            // }
            // let calc = new Calculator;

            // alert( calc.calculate("3 + 7") ); // 10
         /*    你有一个 user 对象数组，每个对象都有 user.name。编写将其转换为 names 数组的代码。

            例如： */

            // let john = { name: "John", age: 25 };
            // let pete = { name: "Pete", age: 30 };
            // let mary = { name: "Mary", age: 28 };

            // let users = [ john, pete, mary ];

            // let names = users.map(item=>item.name) /* ... your code */

            // alert( names ); // John, Pete, Mary
/*          你有一个 user 对象数组，每个对象都有 name，surname 和 id。
            编写代码以该数组为基础，创建另一个具有 id 和 fullName 的对象数组，其中 fullName 由 name 和 surname 生成。
            例如： */

            // let john = { name: "John", surname: "Smith", id: 1 };
            // let pete = { name: "Pete", surname: "Hunt", id: 2 };
            // let mary = { name: "Mary", surname: "Key", id: 3 };

            // let users = [ john, pete, mary ];

            // // let usersMapped = users.map(user => ({
            // // fullName: `${user.name} ${user.surname}`,
            // // id: user.id
            // // }));
            // let usersMapped =users.map(function (user) {
            //     return {
            //           fullName: `${user.name} ${user.surname}`,
            //           id: user.id
            //     }
            //   }
            // )
            // console.log(usersMapped)

            // /*
            // usersMapped = [
            // { fullName: "John Smith", id: 1 },
            // { fullName: "Pete Hunt", id: 2 },
            // { fullName: "Mary Key", id: 3 }
            // ]
            // */

            // alert( usersMapped[0].id ) // 1
            // alert( usersMapped[0].fullName ) // John Smith
           /*  编写函数 sortByAge(users) 获得对象数组的 age 属性，并根据 age 对这些对象数组进行排序。

            例如： */
            // function sortByAge(users){
            //     arr.sort((a,b)=>a.age-b.age)
            // }
            // let john = { name: "John", age: 25 };
            // let pete = { name: "Pete", age: 30 };
            // let mary = { name: "Mary", age: 28 };

            // let arr = [ pete, john, mary ];

            // sortByAge(arr);

            // // now: [john, mary, pete]
            // alert(arr[0].name); // John
            // alert(arr[1].name); // Mary
            // alert(arr[2].name); // Pete
/*          编写函数 shuffle(array) 来随机排列数组的元素。

            多次运行 shuffle 可能导致元素顺序的不同。例如： */
            // function  shuffle(array){ 
            // //    array.sort(()=>Math.random()-0.5)
            // //Fisher-Yates shuffle 解构分配
            //  for(let i=array.length-1;i>0;i--){
            //     let j=Math.floor(Math.random()*(i+1));
            //     [array[i], array[j]] = [array[j], array[i]];
            //  }
            // }
            // let arr = [1, 2, 3];

            // // shuffle(arr);
            // // // arr = [3, 2, 1]

            // // shuffle(arr);
            // // // arr = [2, 1, 3]

            // // shuffle(arr);
            // // arr = [3, 1, 2]
            // // ...
            // let count={
            //     "123": 0,
            //     "231": 0,
            //     "321": 0,
            //     "132": 0,
            //     "213": 0,
            //     "312": 0
            // }
            // let ii=0;
            // while(ii<10000){
            //    shuffle(arr);
            //    count[arr.join("")]++
            //     ii++
            // }
            // console.log(count)
            /* 编写 getAverageAge(users) 函数，该函数获取一个具有 age 属性的对象数组，并返回平均年龄。
            平均值的计算公式是 (age1 + age2 + ... + ageN) / N。
            例如： */
            // function getAverageAge(users){
            //     // var count=0;
            //     // for(user of users){
            //     //     count+=user.age
            //     // }
            //     // return count/users.length
            //     return users.reduce((pre,user)=>pre+user.age,0)
            // }
            // let john = { name: "John", age: 25 };
            // let pete = { name: "Pete", age: 30 };
            // let mary = { name: "Mary", age: 29 };

            // let arr = [ john, pete, mary ];

            // alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
/*             arr 是一个数组。
            创建一个函数 unique(arr)，返回去除重复元素后的数组 arr。
            例如： */

            // function unique(arr) {
            // /* your code */
            // let newArr=[]
            // for(val of arr){
            //     newArr.includes(val)||newArr.push(val)
            // }
            // console.log(newArr)
            // return newArr;
            // }

            // let strings = ["Hare", "Krishna", "Hare", "Krishna",
            // "Krishna", "Krishna", "Hare", "Hare", ":-O"
            // ];

            // alert( unique(strings) ); // Hare, Krishna, :-O
/*          假设我们收到了一个用户数组，形式为：{id:..., name:..., age... }。
            创建一个函数 groupById(arr) 从该数组创建对象，以 id 为键（key），数组项为值。
            例如: */
            // function groupById(array) {
            //     return array.reduce((obj, value) =>{
            //         obj[value.id]=value
            //         return obj}
            //         , {})
            //     }
            // let users = [
            // {id: 'john', name: "John Smith", age: 20},
            // {id: 'ann', name: "Ann Smith", age: 24},
            // {id: 'pete', name: "Pete Peterson", age: 31},
            // ];

            // let usersById = groupById(users);
            // console.log(usersById)
            /*
            // 调用函数后，我们应该得到：

            usersById = {
            john: {id: 'john', name: "John Smith", age: 20},
            ann: {id: 'ann', name: "Ann Smith", age: 24},
            pete: {id: 'pete', name: "Pete Peterson", age: 31},
            }
            */
            /* 处理服务端数据时，这个函数很有用。
            在这个任务里我们假设 id 是唯一的。没有两个具有相同 id 的数组项。
            请在解决方案中使用数组的 .reduce 方法。 */
            // let likeArray={ //array-like 类数组 有索引和length的对象叫类数组
            //     [0]:0,
            //     [1]:1,
            //     length:2
            // }
            // let iterable = {//iterable矢代对象包含Symbol.iterator方法的对象
            //     from:3,
            //     to:5,
            //     [Symbol.iterator](){
            //         this.current=this.from
            //         return this
            //     },
            //     next(){
            //         if(this.current<=this.to){
            //             return {done:false,value:this.current++}
            //         }else{
            //             return {done:true}
            //         }
            //     }
            // }
            // for(let num of iterable){
            //     alert(num)
            // }
            // let str = "Hello";

            // // 和 for..of 做相同的事
            // // for (let char of str) alert(char);

            // let iterator = str[Symbol.iterator]();

            // while (true) {
            // let result = iterator.next();
            // if (result.done) break;
            // alert(result.value); // 一个接一个地输出字符
            // }
            // function slice(str,s,e) { 
            //     return Array.from(str).slice(s,e).join('')
            //  }
            // let str = '𝒳😂𩷶';

            // alert( slice(str, 1, 3) ); // 😂𩷶

            // // 原生方法不支持识别代理对（译注：UTF-16 扩展字符）
            // alert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）
            // let map = new Map();

            // map.set('1', 'str1');   // 字符串键
            // map.set(1, 'num1');     // 数字键
            // map.set(true, 'bool1'); // 布尔值键
            // map[2]=2
            // map["2"]=3
            // console.log(map,map[2],map.get(1))
            // let map = new Map([
            // ['1',  'str1'],
            // [1,    'num1'],
            // [true, 'bool1']
            // ]);
            // let obj = {
            // name: "John",
            // age: 30
            // };

            // let map = new Map(Object.entries(obj));
            // console.log(map)
            // let map = new Map();
            // map.set('banana', 1);
            // map.set('orange', 2);
            // map.set('meat', 4);
            // map.set('orange', 3);
            // console.log(map)
            // let obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)
            
            // // 完成了！
            // // obj = { banana: 1, orange: 2, meat: 4 }

            // alert(obj.orange); // 2
        /*     定义 arr 为一个数组。
            创建一个函数 unique(arr)，该函数返回一个由 arr 中所有唯一元素所组成的数组。
            例如： */
    //         function unique(arr) {
    //         /* 你的代码 */
    //             // var set=new Set();
    //             // for(val of arr){
    //             //     set.add(val)
    //             // }
    //             // return Array.from(set);
    //             return Array.from(new Set(arr))

    //         }

    //         let values = ["Hare", "Krishna", "Hare", "Krishna",
    //         "Krishna", "Krishna", "Hare", "Hare", ":-O"
    //         ];

    //         alert( unique(values) ); // Hare, Krishna, :-O
    //  /*     P.S. 这里用到了 string 类型，但其实可以是任何类型的值。

    //         P.S. 使用 Set 来存储唯一值。 */
/*             Anagrams 是具有相同数量相同字母但是顺序不同的单词。
： */

                // nap - pan
                // ear - are - era
                // cheaters - hectares - teachers
                // 写一个函数 aclean(arr)，它返回被清除了字谜（anagrams）的数组。

                // 例如：
                // function aclean(arr){
                //     let map=new Map()
                //     for(ar of arr){
                //         let sortAr=ar.toLowerCase().split("").sort().join('')
                //         map.set(sortAr,ar)
                //     }
                //     return Array.from(map.values())
                // }
                // let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

                // alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
                // // 对于所有的字谜（anagram）组，都应该保留其中一个词，但保留的具体是哪一个并不重要。
               /*  我们期望使用 map.keys() 得到一个数组，然后使用特定的方法例如 .push 等，对其进行处理。
                但是运行不了： */

                // let map = new Map();
                // map.set("name", "John");
                // let keys = map.keys();
                // keys=Array.from(keys)
                // // Error: keys.push is not a function
                // keys.push("more");
                // console.log(keys)
                // let visitedSet = new WeakSet();

                // let john = { name: "John" };
                // let pete = { name: "Pete" };
                // let mary = { name: "Mary" };

                // visitedSet.add(john); // John 访问了我们
                // visitedSet.add(pete); // 然后是 Pete
                // visitedSet.add(john); // John 再次访问

                // // visitedSet 现在有两个用户了

                // // 检查 John 是否来访过？
                // // alert(visitedSet.has(john)); // true

                // // // 检查 Mary 是否来访过？
                // // alert(visitedSet.has(mary)); // false

                // john = null;
                // console.log(visitedSet)
             /*    存储 "unread" 标识
                重要程度: 5
                这里有一个 messages 数组： */

                // let messages = [
                // {text: "Hello", from: "John"},
                // {text: "How goes?", from: "John"},
                // {text: "See you soon", from: "Alice"}
                // ];
                // let readMessages=new WeakSet()
                
                // // 两个消息已读
                // readMessages.add(messages[0]);
                // readMessages.add(messages[1]);
                // // readMessages 包含两个元素

                // // ……让我们再读一遍第一条消息！
                // readMessages.add(messages[0]);
                // alert("Read message 0: " + readMessages.has(messages[0])); // true
                // // messages.splice(0,1);
                // messages.shift()
                // console.log(messages)
                // // symbol 属性仅对于我们的代码是已知的
                // let isRead = Symbol("isRead");
                // messages[0][isRead] = true;
                // console.log(isRead,messages)
                // 现在 readMessages 有一个元素（技术上来讲，内存可能稍后才会被清理）
                // readMessages 仍然有两个不重复的元素
               /*  你的代码可以访问它，但是 message 是由其他人的代码管理的。该代码会定期添加新消息，删除旧消息，但是你不知道这些操作确切的发生时间。
                现在，你应该使用什么数据结构来保存关于消息“是否已读”的信息？该结构必须很适合对给定的 message 对象给出“它读了吗？”的答案。
                P.S. 当一个消息被从 messages 中删除后，它应该也从你的数据结构中消失。
                P.S. 我们不能修改 message 对象，例如向其添加我们的属性。因为它们是由其他人的代码管理的，我们修改该数据可能会导致不好的后果。 */
     /*            这儿有一个和 上一个任务 类似的 messages 数组。场景也相似。 */

//                 let messages = [
//                 {text: "Hello", from: "John"},
//                 {text: "How goes?", from: "John"},
//                 {text: "See you soon", from: "Alice"}
//                 ];
                // /* 现在的问题是：你建议采用什么数据结构来保存信息：“消息是什么时候被阅读的？”。
                // 在前一个任务中我们只需要保存“是/否”。现在我们需要保存日期，并且它应该在消息被垃圾回收时也被从内存中清除。
                // P.S. 日期可以存储为内建的 Date 类的对象，稍后我们将进行介绍。 */
             /*    有一个带有任意数量薪水的 salaries 对象。
                编写函数 sumSalaries(salaries)，该函数使用 Object.values 和 for..of 循环返回所有薪水的总和。
                如果 salaries 是空对象，那么结果必须是 0。 */
                // function sumSalaries(salaries){
                //     return Object.values(salaries).reduce((count,val)=>count+val,0)
                // }
                // let salaries = {
                // "John": 100,
                // "Pete": 300,
                // "Mary": 250
                // };

                // alert( sumSalaries(salaries) ); // 650
                // 写一个函数 count(obj)，该函数返回对象中的属性的数量：
                // function count(obj){
                //     return Object.keys(obj).length;
                // }
                // let user = {
                // name: 'John',
                // age: 30
                // };

                // alert( count(user) ); // 2
                // // 试着使代码尽可能简短。
                // // P.S. 忽略 Symbol 类型属性，只计算“常规”属性。
                // let [a, b, c] = "abc"; // ["a", "b", "c"]
                // let [one, two, three] = new Set([1, 2, 3]);
                // let fb = new Map([[1]])
                // console.log(one,two,three,fb)
                // let [firstName, surname]=[0,1]
                // alert(firstName); // undefined
                // alert(surname); // undefined
                // 写一个解构赋值语句使得：

                // name 属性赋值给变量 name。
                // years 属性赋值给变量 age。
                // isAdmin 属性赋值给变量 isAdmin（如果属性缺失则取默认值 false）。
                // 下面是赋值完成后的值的情况：

                // let user = { name: "John", years: 30 };

                // // 等号左侧是你的代码
                // // ... = user
                // let {name,isAdmin=false,years:age}=user
                // alert( name ); // John
                // alert( age ); // 30
                // alert( isAdmin ); // false
                // 这儿有一个 salaries 对象：

                // let salaries = {
                // "John": 100,
                // "Pete": 300,
                // "Mary": 250
                // };
                // function topSalary(salaries) {
                //     // let map=new Map(Object.entries(salaries));
                //     // let obj = Object.fromEntries(map.entries());
                //     // let arr=Object.entries(salaries)
                //     // let max=arr[0];
                //     // for(index in arr){
                //     //     console.log(arr[index])
                //     //     if(arr[index][1]>max[1]&&index>0) max=arr[index]
                //     // }
                //     // // console.log(map,obj)
                //     // return max[0]
                //     let maxVal=0,maxName
                //     for(let [name,value] of Object.entries(salaries)){
                //         if(value>maxVal){
                //             maxVal=value 
                //             maxName=name
                //         } 
                //         console.log(name,value)
                //     }
                //     return maxName
                   
                //   }
                //   alert(topSalary(salaries))
                // 新建一个函数 topSalary(salaries)，返回收入最高的人的姓名。

                // 如果 salaries 是空的，函数应该返回 null。
                // 如果有多个收入最高的人，返回其中任意一个即可。
                // P.S. 使用 Object.entries 和解构语法来遍历键/值对。
                // 创建日期
                // 重要程度: 5
                // 创建一个 Date 对象，日期是：Feb 20, 2012, 3:12am。时区是当地时区。
                // alert(new Date("2012-2-20 03:12"))//"February 20, 2012 03:12:00"
                // alert(new Date(2012,1,20,03,12))
                //    alert(new Date("February 20 2012 03:12:00"))
                // 使用 alert 显示结果。
                // 编写一个函数 getWeekDay(date) 以短格式来显示一个日期的星期数：‘MO’，‘TU’，‘WE’，‘TH’，‘FR’，‘SA’，‘SU’。
                // function getWeekDay(date) { 
                //     console.log(date.getDay())
                //     // return new Intl.DateTimeFormat('en-US',{weekday:"long"}).format(date.getDay())//{weekday:"short/long/narrow"}
                //     let options={
                //         weekday:"long"
                //     }
                //     // return new Intl.DateTimeFormat('zh-CN',options).format(date)
                //     return new Intl.DateTimeFormat('en-US',options).format(date).slice(0,2).toUpperCase()
                // }
                // // function getWeekDay(date) {
                // //     let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

                // //     return days[date.getDay()];
                // //     }
                // let date = new Date(2014, 0, 3);  // 3 Jan 2012
                // alert( getWeekDay(date) );        // 应该输出 "FR"
                // 欧洲的星期表示方法
                // 重要程度: 5
                // 欧洲国家的星期计算是从星期一（数字 1）开始的，然后是星期二（数字 2），直到星期日（数字 7）。编写一个函数 getLocalDay(date)，并返回日期的欧洲式星期数。
                //     function getLocalDay(date) { 
                //         // let days = ['星期一', '星期二', '星期三', '星期四', '星期五', '星期六', '星期日'];
                //         // return days[date.getDay()-1];
                //         // let day = date.getDay();

                //         // if (day == 0) { // weekday 0 (sunday) is 7 in european
                //         // day = 7;
                //         // }

                //         // return day;
                //         let option={
                //             weekday:"long"
                //         }
                //         return new Intl.DateTimeFormat('zh-CN',option).format(date)
                //      }
                // let date = new Date(2012, 0, 3);  // 3 Jan 2012
                // alert( getLocalDay(date) );       // 星期二，应该显示 2
                // 许多天之前是哪个月几号？
                // 重要程度: 4
                // 写一个函数 getDateAgo(date, days)，返回特定日期 date 往前 days 天是哪个月的哪一天。

                // 例如，假设今天是 20 号，那么 getDateAgo(new Date(), 1) 的结果应该是 19 号，getDateAgo(new Date(), 2) 的结果应该是 18 号。

                // 跨月、年也应该是正确输出：
                // function getDateAgo(date, days){
                
                // // let dateCopy = new Date(date);

                // // dateCopy.setDate(date.getDate() - days);
                // // return dateCopy.getDate();
                // console.log(date)
                // let dateCopy = new Date(date);
                // console.log(date,dateCopy)
                // dateCopy.setDate(date.getDate() - days);
                // return dateCopy.getDate();
                // }
                // let date = new Date(2015, 0, 2);

                // console.log( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
                // console.log( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
                // console.log( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
                // P.S. 函数不应该修改给定的 date 值。
                // 写一个函数 getLastDayOfMonth(year, month) 返回 month 月的最后一天。有时候是 30，有时是 31，甚至在二月的时候会是 28/29。

                // 参数：

                // year —— 四位数的年份，比如 2012。
                // month —— 月份，从 0 到 11。
                // 举个例子，getLastDayOfMonth(2012, 1) = 29（闰年，二月）
                // function getLastDayOfMonth(year, month) { 
                //     // return new Date(new Date(year, month+1).setDate(0)).getDate()
                //     // let date=new Date(year, month+1,0)
                //     // return date.getDate()
                //     return new Date(year, month+1,0).getDate()
                //  }

                // console.log(getLastDayOfMonth(2012, 1))
                // 写一个函数 getSecondsToday()，返回今天已经过去了多少秒？

                // 例如：如果现在是 10:00 am，并且没有夏令时转换，那么：
                //  function getSecondsToday(){
                //     // let now = new Date();

                //     // // 使用当前的 day/month/year 创建一个对象
                //     // let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                //     // let diff = now - today; // ms difference
                //     // return Math.round(diff / 1000); // make seconds
                //     let d = new Date();
                //     return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
                //  }
                // console.log(getSecondsToday() ); 
                // 该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。
                // 距离明天还有多少秒？
                // 重要程度: 5
                // 写一个函数 getSecondsToTomorrow()，返回距离明天的秒数。

                // 例如，现在是 23:00，那么：
            //     function getSecondsToTomorrow(){  
            //         let now=new Date();
            //         // let tomorrow=new Date().setDate(now.getDate()+1)
            //         let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);
            //         // console.log(new Date(tomorrow))
            //         return Math.round((tomorrow-now)/1000)
            //     }
            //    console.log( getSecondsToTomorrow()) /* == 3600 */
            //     // P.S. 该函数应该在任意一天都能正确运行。那意味着，它不应具有“今天”的硬编码值。
            // 写一个函数 formatDate(date)，能够对 date 进行如下格式化：

            // 如果 date 距离现在不到 1 秒，输出 "right now"。
            // 否则，如果 date 距离现在不到 1 分钟，输出 "n sec. ago"。
            // 否则，如果不到 1 小时，输出 "m min. ago"。
            // 否则，以 "DD.MM.YY HH:mm" 格式输出完整日期。即："day.month.year hours:minutes"，全部以两位数格式表示，例如：31.12.16 10:00。
            // 举个例子：
            // function formatDate(date){
            //     let now=new Date();
            //     let diff=now-date;
            //     console.log(diff)
            //     let result=`${date.getFullYear().toString().slice(2)}.${(date.getMonth()/100).toString().split(".")[1]}.${(date.getDate()/100).toString().split(".")[1]} ${(date.getHours()/100).toString().split(".")[1]}:${(date.getMinutes()/100).toString().split(".")[1]}`
            //    if(diff <= 1000){
            //         result="right now"
            //    }
            //    else if(diff<=30 * 1000){
            //         result="30 sec. ago"
            //    }
            //    else if(diff<= 5 * 60 * 1000){
            //         result="5 min. ago"
            //    }
            //     return result
            // }
            // alert( formatDate(new Date(new Date - 1)) ); // "right now"
            // alert( formatDate(new Date(new Date - 30 * 1000)) ); // "30 sec. ago"
            // alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "5 min. ago"
            // // 昨天的日期，例如 31.12.16 20:00
            // alert( formatDate(new Date(new Date - 86400 * 1000)) );
            // 将 user 转换为 JSON，然后将其转换回到另一个变量。

            // let user = {
            // name: "John Smith",
            // age: 35
            // };
            // JSON.parse 内字符串 stringify内对象
            // console.log(JSON.parse(JSON.stringify(user)),typeof JSON.stringify(user),typeof user)
            // 排除反向引用
            // 重要程度: 5
            // 在简单循环引用的情况下，我们可以通过名称排除序列化中违规的属性。
            // 但是，有时我们不能只使用名称，因为它既可能在循环引用中也可能在常规属性中使用。因此，我们可以通过属性值来检查属性。
            // 编写 replacer 函数，移除引用 meetup 的属性，并将其他所有属性序列化：

            // let room = {
            // number: 23
            // };

            // let meetup = {
            // title: "Conference",
            // occupiedBy: [{name: "John"}, {name: "Alice"}],
            // place: room
            // };

            // // 循环引用
            // room.occupiedBy = meetup;
            // meetup.self = meetup;

            // alert( JSON.stringify(meetup, function replacer(key, value) {
            // /* your code */
            // if(key != "" &&value==meetup) return value=undefined
            // return value
            // }));

            // /* 结果应该是：
            // {
            // "title":"Conference",
            // "occupiedBy":[{"name":"John"},{"name":"Alice"}],
            // "place":{"number":23}
            // }
            // */
            // 编写一个函数 sumTo(n) 计算 1 + 2 + ... + n 的和。

            // 举个例子：

            // sumTo(1) = 1
            // sumTo(2) = 2 + 1 = 3
            // sumTo(3) = 3 + 2 + 1 = 6
            // sumTo(4) = 4 + 3 + 2 + 1 = 10
            // ...
            // sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
            // 用三种方式实现：

            // 使用循环。
            // 使用递归，对 n > 1 执行 sumTo(n) = n + sumTo(n-1)。
            // 使用 等差数列 求和公式.
            // 结果示例：

            // function sumTo(n) { 
            //     /*... 你的代码 ... */
            //     // 使用循环。
            //     // let sum=0;
            //     // for(let i=n;i>0;i--){
            //     //     sum+=i
            //     // }
            //     // return sum
            //     // 使用递归，对 n > 1 执行 sumTo(n) = n + sumTo(n-1)。
            //         // if(n<2){
            //         //     return n;
            //         // }else{
            //         //     return n+sumTo(n-1)
            //         // }
            //     // 使用 等差数列 求和公式.
            //     //    return (n+1)*(n/2)
            //     return n*(n+1)/2

            //  }

            // alert( sumTo(100) ); // 5050
            // // P.S. 哪种解决方式最快？哪种最慢？为什么？

            // // P.P.S. 我们可以使用递归来计算 sumTo(100000) 吗？
            // // 自然数的 阶乘 是指，一个数乘以 数字减去 1，然后乘以 数字减去 2，以此类推直到乘以 1。n 的阶乘被记作 n!。

            // // 我们可以将阶乘的定义写成这样：

            // // n! = n * (n - 1) * (n - 2) * ...*1
            // // 不同 n 的阶乘的值：

            // // 1! = 1
            // // 2! = 2 * 1 = 2
            // // 3! = 3 * 2 * 1 = 6
            // // 4! = 4 * 3 * 2 * 1 = 24
            // // 5! = 5 * 4 * 3 * 2 * 1 = 120
            // // 任务是编写一个函数 factorial(n) 使用递归调用计算 n!。
            // function factorial(n) { 
            //     // if(n==1) return n
            //     // return n*factorial(n-1)
            //     return n>1?n*factorial(n-1):1
            //  }
            // alert( factorial(5) ); // 120
            // // P.S. 提示：n! 可以被写成 n * (n-1)!，比如 3! = 3*2! = 3*2*1! = 6。
            // 斐波那契数 序列有这样的公式： Fn = Fn-1 + Fn-2。换句话说，下一个数字是前两个数字的和。

            // 前两个数字是 1，然后是 2(1+1)，然后 3(1+2)，5(2+3) 等：1, 1, 2, 3, 5, 8, 13, 21...。

            // 斐波那契数与 黄金比例 以及我们周围的许多自然现象有关。

            // 编写一个函数 fib(n) 返回第 n 个斐波那契数。

            // 工作示例：

            // function fib(n) { 
            //     /* 你的代码 */ 
            //     // return n>1?fib(n-1)+fib(n-2):n
            //     // return n <= 1 ? n : fib(n - 1) + fib(n - 2);
            //     // 1, 1, 2, 3, 5, 8, 13, 21...。
            //     //a=b 
            //     //b=c
            //     //c=a+b
            //     let a=1
            //     let b=1 
            //     for(let i=3;i<=n;i++){
            //         let c=a+b
            //          a=b
            //          b=c
            //     }
            //     return b
            // }

            // alert(fib(3)); // 2
            // alert(fib(7)); // 13
            // alert(fib(8)); // 5527939700884757
            // P.S. 函数运行速度要快，对 fib(77) 的调用不应该超过几分之一秒。
            // 假设我们有一个单链表（在 递归和堆栈 那章有讲过）：

            // let list = {
            // value: 1,
            // next: {
            //     value: 2,
            //     next: {
            //     value: 3,
            //     next: {
            //         value: 4,
            //         next: null
            //     }
            //     }
            // }
            // };
            // function printList(list) { 
            //     // 使用两种方式实现：循环和递归。
            //     //循环
            //     // for(let [key,value] of Object.entries(list)){
            //     //    if(key=="next"&&value!=null){
            //     //      for(let [ke,va] of Object.entries(value)){
            //     //         if(ke=="next"&&va!=null){
            //     //             for(let [k,v] of Object.entries(va)){
            //     //                 if(k=="next"&&v!=null){
            //     //                     for(let [k1,v1] of Object.entries(v)){
            //     //                         console.log(k1,v1)
            //     //                     }
            //     //                     }else{
            //     //                         console.log(k,v)
            //     //                     }
            //     //                  }
            //     //         }else{
            //     //             console.log(ke,va)
            //     //         }
            //     //      }
            //     //    }else{
            //     //     console.log(key,value)
            //     //    } 
                
            //     // }
            //     //循环2
            //     // let tmp=list
            //     // while(tmp){
            //     //     alert(tmp.value)
            //     //     tmp=tmp.next
            //     // }
            //     //递归
            //     // alert(list.value)
            //     // // let tmp=list.next
            //     // // tmp&&printList(tmp)
            //     // if (list.next) {
            //     //     printList(list.next); // 链表中其余部分同理
            //     // }
            //     // 反向输出前一个任务 输出一个单链表 中的单链表。
            //     // 使用两种解法：循环和递归。
            //     // let arr=[]
            //     // while(list){
            //     //     arr.push(list.value)
            //     //     list=list.next
            //     // }
            //     // // while(arr){
            //     // //     if(arr.length==0) break
            //     // //     console.log(arr.pop())
            //     // // }
            //     // while(arr.length){
            //     //     console.log(arr.pop())
            //     // }
            //     // for (let i = arr.length - 1; i >= 0; i--) {
            //     //     alert( arr[i] );
            //     // }
            //     //反向递归
            // //    list.next&&printList(list.next)
            // //    alert(list.value)
            //  }
            //  printList(list)
            // 编写一个可以逐个输出链表元素的函数 printList(list)。
            // 使用两种方式实现：循环和递归。
            // 哪个更好：用递归还是不用递归的？

            // Object.assign(dest, src1, ..., srcN)
            // let [src1,src2]=[{name:1},{age:2}]
            // // let {name:src1,...src2}={name:1,age:2}
            // // console.log(src1,src2)
            // let dest={}
            // Object.assign(dest,src1,src2)
            // console.log(dest)
            // let arr = [1, 2, 3];
            // let arrCopy = [...arr];
            // console.log(arr,arrCopy)
            // console.log(JSON.stringify(arr)===JSON.stringify(arrCopy))
            // let i=0
            // console.log(i++,i,++i,i)
            // 编写一个像 sum(a)(b) = a+b 这样工作的 sum 函数。
            // 是的，就是这种通过双括号的方式（并不是错误）。
            // 举个例子：
            // function sum(a) { 
            //     return function(b) {
            //          return a+b
            //       }
            //  }
            // alert(sum(1)(2)) /* = 3 */
            // alert(sum(5)(-1)) /* = 4 */
            // /* .. inBetween 和 inArray 的代码 */filter函数true会返回
            // let arr = [1, 2, 3, 4, 5, 6, 7];
            // function inBetween(a,b) {
            //     return function(x){
            //         return x>=a&&x<=b
            //     }
            // }
            // function inArray(arr) {
            //    return  function (x) {
            //     return arr.includes(x);
            //      }
                
            // }   
            // alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6 

            // alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
            // let users = [
            // { name: "John", age: 20, surname: "Johnson" },
            // { name: "Pete", age: 18, surname: "Peterson" },
            // { name: "Ann", age: 19, surname: "Hathaway" }
            // ];
            // function byField(fieldName){
            //     // return function(a,b){
            //     //     return a[fieldName]>b[fieldName]?1:-1
            //     // }
            //     return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;
            // }
            // console.log(users.sort(byField('name')));
            // console.log(users.sort(byField('age')));
            // 下列的代码创建了一个 shooters 数组。
            // 每个函数都应该输出其编号。但好像出了点问题……

            // function makeArmy() {
            // let shooters = [];

            // let i = 0; //let army = makeArmy()后此时i=10 当调用shooter()时因外部i!<10所以直接跳过 不会生成新环境
            // while (i < 10) {
                
            //     let j=i //
            //     let shooter = function() { // 创建一个 shooter 函数， /这一段shooter存储一个方法 方法内未执行

            //         alert( j ); // 应该显示其编号
            //     };
            //     shooters.push(shooter); // 将此 shooter 函数添加到数组中 
            //     i++;
            // }

            // // ……返回 shooters 数组
            // return shooters;
            // }
           
            // let army = makeArmy();
            // // console.log(army.toString())
            // // ……所有的 shooter 显示的都是 10，而不是它们的编号 0, 1, 2, 3...
            // army[0](); // 编号为 0 的 shooter 显示的是 10
            // army[1](); // 编号为 1 的 shooter 显示的是 10
            // army[2](); // 10，其他的也是这样。
            // if(true){
            //     var a=1 //声明会被提升，但是赋值不会。
            //     let b=2 //块级作用域
            // }
            // console.log(a)//1
            // console.log(b)//b is not defined
            // 为 counter 添加 set 和 decrease 方法
            // 重要程度: 5
            // 修改 makeCounter() 代码，使得 counter 可以进行减一和设置值的操作：
            // function makeCounter() {
            //     let count = 0;
            //     function counter() { 
            //         return count ++
            //      }
            //      counter.set=function(value){
            //         count=value
            //      }
            //      counter.decrease=function(value){
            //         count--
            //      }
            //      return counter
                
            //     // ... your code ...
            //     }
                
            //     let counter = makeCounter();
                
            //     alert( counter() ); // 0
            //     alert( counter() ); // 1
                
            //     counter.set(10); // set the new count
                
            //     alert( counter() ); // 10
                
            //     counter.decrease(); // decrease the count by 1
                
            //     alert( counter() ); // 10 (instead of 11)
            // counter() //应该返回下一个数字（与之前的逻辑相同）。
            // counter.set(value) //应该将 count 设置为 value。
            // counter.decrease(value) //应该把 count 减 1。
            // 查看沙箱中的代码获取完整使用示例。

            // P.S. 你可以使用闭包或者函数属性来保持当前的计数，或者两种都写。
           
            // function sum(a){
            //     // Your code goes here.
            //   let currentSum=a
            //   function f(b) {
            //       currentSum+=b
            //       return f
            //     }
            //     f.toString=function(){
            //         return currentSum
            //     }
            // return f
                
            
            // }
            // alert(sum(1)(2) )
            // alert(sum(1)(2)(3) )
            // alert(sum(5)(-1)(2))
            // alert(sum(6)(-1)(-2)(-3))
            // alert(sum(0)(1)(2)(3)(4)(5))
            /*
            sum(1)(2) == 3; // 1 + 2
            sum(1)(2)(3) == 6; // 1 + 2 + 3
            sum(5)(-1)(2) == 6
            sum(6)(-1)(-2)(-3) == 0
            sum(0)(1)(2)(3)(4)(5) == 15
            */
            // let a = new Function('a', 'b', 'return a + b'); // 基础语法
            // let b = new Function('a,b', 'return a + b'); // 逗号分隔
            // let c = new Function('a , b', 'return a + b'); // 逗号和空格分隔

            // alert(a(1,2))
            // alert(b(1,2))
            // alert(c(1,2))
            // function sayHi(phrase, who) {
            // alert( phrase + ', ' + who );
            // }

            // setTimeout(sayHi, 2000, "Hello", "John"); // Hello, John
            // setTimeout(sayHi("Hello", "John"), 2000); // Hello, John
            // let timerId = setTimeout(function tick() {
            // alert('tick');
            // timerId = setTimeout(tick, 2000); // (*)
            // }, 2000);
            // setTimeout(function(){
            //     clearTimeout(timerId)
            // },8000)
            // 编写一个函数 printNumbers(from, to)，使其每秒输出一个数字，数字从 from 开始，到 to 结束。

            // 使用以下两种方法来实现。

            // 使用 setInterval。
            // 使用嵌套的 setTimeout。
            // function printNumbers(from, to) {
            //     // let si=setInterval(function () { 
            //     //     console.log(from++)
            //     //     if(from>to){
            //     //         clearInterval(si)
            //     //     }
            //     //   },1000)
            //    let st = setTimeout(function xh() {  
            //         console.log(from++)
            //         if(from<=to){
            //              st=setTimeout(xh,1000)
            //         }   
            //     }, 1000);
            //   }
            //   printNumbers(1,5)
            // function slow(x) {
            // // 这里可能会有重负载的 CPU 密集型工作
            // alert(`Called with ${x}`);
            // return x;
            // }

            // function cachingDecorator(func) {
            // let cache = new Map();

            // return function(x) {
            //     if (cache.has(x)) {    // 如果缓存中有对应的结果
            //     return cache.get(x); // 从缓存中读取结果
            //     }

            //     let result = func(x);  // 否则就调用 func

            //     cache.set(x, result);  // 然后将结果缓存（记住）下来
            //     return result;
            // };
            // }

            // slow = cachingDecorator(slow);

            // alert( slow(1) ); // slow(1) 被缓存下来了
            // alert( "Again: " + slow(1) ); // 一样的

            // alert( slow(2) ); // slow(2) 被缓存下来了
            // alert( "Again: " + slow(2) ); // 和前面一行结果相同
            // function a() {
            //     console.log(1)
            //     return 0
            //   }
            //   let b=a()
            //   console.log(b)
            // let arr=[1,2,'console.log(this)']
            // af=new Function(arr[2])
            // af()
            // let object={
            //     con:console.log(this),
            //     func:function(){
            //         console.log(this)
            //     }
            // }
            // object.con
            // object.func()
            // function fc(){
            //     return function(){
            //         object.func.call(this)
            //         console.log(this)
            //     }
            // }
            // fc()()
            // 创建一个装饰器 spy(func)，它应该返回一个包装器，该包装器将所有对函数的调用保存在其 calls 属性中。

            // 每个调用都保存为一个参数数组。

            // 例如：
            // function spy(func) { 
            //     function newFunc(...arg){
            //         newFunc.calls.push(arg)
            //         return func.apply(this,arg)
            //     }
            //     newFunc.calls = [];//此时work已变成对象
            //     return newFunc
            // }
            // function work(a, b) {
            // alert( a + b ); // work 是一个任意的函数或方法
            // }
            
            // work = spy(work);//this指向最后调用的对象也就是work

            // work(1, 2); // 3
            // work(4, 5); // 9
            // console.log(work.calls)
            // for (let args of work.calls) {
            // alert( 'call:' + args.join() ); // "call:1,2", "call:4,5"
            // // }
            // // 创建一个装饰器 delay(f, ms)，该装饰器将 f 的每次调用延时 ms 毫秒。

            // // 例如：
            // function delay(f, ms){
                
            //    return function () {
            //         //   setTimeout(function () {
            //         //       f.apply(this, arguments)
            //         //     },ms)
            //         setTimeout(() => f.apply(this, arguments), ms);
            //         clea
            //      }
                  
                  
            // }
            // function f(x) {
            // alert(x);
            // }

            // // create wrappers
            // let f1000 = delay(f, 1000);
            // let f1500 = delay(f, 1500);

            // f1000("test"); // 在 1000ms 后显示 "test"
            // f1500("test"); // 在 1500ms 后显示 "test"
            // // 换句话说，delay(f, ms) 返回的是延迟 ms 后的 f 的变体。

            // // 在上面的代码中，f 是单个参数的函数，但是你的解决方案应该传递所有参数和上下文 this。
            // let user = {
            // firstName: "John",
            // sayHi() {
            //     alert(`Hello, ${this.firstName}!`);
            // }
            // };
            // // setTimeout(function () {
            // //     user.sayHi()
            // //   }, 1000); // Hello, undefined!
            // setTimeout(()=>user.sayHi(),1000)
            // let user = {
            // firstName: "John"
            // };

            // function func() {
            // alert(this.firstName);
            // }

            // let funcUser = func.bind(user);
            // funcUser(); // John
            // let data={仙桃: 1, 咸宁: 0, 十堰: 0, 江汉油田: 0}
            // for(let key of Object.keys(data)){
            //     console.log(key,data[key])
            // }
            // let user = {
            // firstName: "John",
            // say(phrase) {
            //     alert(`${phrase}, ${this.firstName}!`);
            // }
            // };
            // let user=[1,1,1,3]
            // for(let key in user){
            //     console.log(key)
            // }
            // function partial(func, ...argsBound) {
            // return function(...args) { // (*)
            //     return func.call(this, ...argsBound, ...args);
            // }
            // }

            // // 用法：
            // let user = {
            // firstName: "John",
            // say(time, phrase) {
            //     alert(`[${time}] ${this.firstName}: ${phrase}!`);
            // }
            // };

            // // 添加一个带有绑定时间的 partial 方法
            // user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

            // user.sayNow("Hello");
            // // 类似于这样的一些内容：
            // // [10:00] John: Hello!
            // function f() {
            // alert(this.name);
            // }

            // f = f.bind( {name: "John"} );
            // f = f.bind( {name: "Pete"} )

            // f(); // John
            // function askPassword(ok, fail) {
            // let password = prompt("Password?", '');
            // if (password == "rockstar") ok();
            // else fail();
            // }

            // let user = {
            // name: 'John',

            // loginOk() {
            //     alert(`${this.name} logged in`);
            // },

            // loginFail() {
            //     alert(`${this.name} failed to log in`);
            // },

            // };
            // for(let key in user){
            //     if(typeof user[key] =="function")  user[key]=user[key].bind(user)
            // }
            // askPassword(user.loginOk, user.loginFail);
            // askPassword(user.loginOk.bind(user), user.loginFail.bind(user));
            // function askPassword(ok, fail) {
            // let password = prompt("Password?", '');
            // if (password == "rockstar") ok();
            // else fail();
            // }

            // let user = {
            // name: 'John',

            // login(result) {
            //     alert( this.name + (result ? ' logged in' : ' failed to log in') );
            // }
            // };

            // // askPassword(user.login.bind(user,true), user.login.bind((user))); // ?
            // askPassword(() => user.login(true), () => user.login(false));
            // let arr=[{name: "John"},{ad: "aa"}]
            // for(let obj of arr){
            //     // console.log(alert(Object.keys(obj)))
            //     // for(let key in obj){
            //     //     console.log(key,obj[key])
            //     // }
            //     // console.log(obj[Object.keys(obj).toString()])
            //     // Object.entries(obj).forEach(ele => {
            //     //     console.log(ele)
            //     // });
            //     // console.log(Object.keys(obj)[0],Object.values(obj)[0])
            //      for(let key in obj){
            //         console.log(key)
            //     }
            // }
        //    console.log(Function.prototype,Function.__proto__,Object.prototype,[123].__proto__.__proto__.__proto__ )
        // Function.prototype.defer=function (ms) {
        //     setTimeout(this,ms)
        //   }
        // function f() {
        // alert("Hello!");
        // }

        // f.defer(1000); // 1 秒后显示 "Hello!"
        // Function.prototype.defer=function (ms) {
        //     let f=this
        //     return function (...args) {
        //         setTimeout(()=>f.apply(this,args),ms)
        //       }
        //   }
        // function f(a, b) {
        // alert( a + b );
        // }

        // f.defer(1000)(1, 2); // 1 秒后显示 3
        // function Rabbit() {}
        // Rabbit.prototype = {
        // eats: true
        // };

        // let rabbit = new Rabbit();
        // console.log( Rabbit.prototype,rabbit.__proto__); // ?
        // Rabbit.prototype = {};
        // let rabbit1 = new Rabbit();
        // console.log( Rabbit.prototype,rabbit.__proto__,rabbit1.__proto__); // ?
        // alert( Rabbit.eats ); // ?
        // alert( rabbit.eats ); // ?
        // let animal = {
        // eats: true
        // };

        // // 创建一个以 animal 为原型的新对象
        // let rabbit = Object.create(animal);
        // let rabbit1={};
        // rabbit1.__proto__=animal
        // console.log(rabbit,rabbit.__proto__, rabbit1, rabbit1.__proto__)
        // alert(rabbit.eats); // true

        // alert(Object.getPrototypeOf(rabbit) === animal); // true

        // Object.setPrototypeOf(rabbit, {}); // 将 rabbit 的原型修改为 {}
        // let obj = {name:1};

        // // let key = prompt("What's the key?", "prototype");
        // // // obj[key] = "some value";

        // // console.log(obj[key]); // [object Object]，并不是 "some value"！
        // console.log(Array.prototype)
        // console.log(Object.getOwnPropertyDescriptor(obj,"name"))
        // let dictionary = Object.create(null,{
        //     toString:{
        //         value(){
        //             console.log(Array.prototype)
        //         return Object.keys(this).join()

        //     }
        //     }
            
             
           
        // });

        // // 你的添加 dictionary.toString 方法的代码
        // // console.log(dictionary,dictionary.__proto__)
        // // 添加一些数据
        // dictionary.apple = "Apple";
        // dictionary.__proto__ = "test"; // 这里 __proto__ 是一个常规的属性键

        // // 在循环中只有 apple 和 __proto__
        // for(let key in dictionary) {
        // alert(key); // "apple", then "__proto__"
        // }

        // // 你的 toString 方法在发挥作用
        // alert(dictionary); // "apple,__proto__"
        // function Rabbit(name) {
        // this.name = name;
        // }
        // Rabbit.prototype.sayHi = function() {
        // alert( this.name );
        // }

        // let rabbit = new Rabbit("Rabbit");

        // rabbit.sayHi();                        // Rabbit
        // console.log( rabbit)
        // Rabbit.prototype.sayHi();              // undefined
        // console.log( Rabbit.prototype)
        // Object.getPrototypeOf(rabbit).sayHi(); // undefined
        // console.log( Object.getPrototypeOf(rabbit))
        // rabbit.__proto__.sayHi();              // undefined
        // console.log(  rabbit.__proto__)
        //九九乘法口诀
        // function getJJ(){
        //     document.write("<table align='center'>");
        //     let html=""
        //     for(let a=1;a<10;a++){ //行
        //         html+="<tr>"
        //         for(let b=1;b<a+1;b++){//列
        //             html+="<td>" + b + "*" + a + "=" + a*b + "</td>"
        //         }
        //         html+="</tr>"
        //     } 
        //     document.write(html)
        //     document.write("<table align='center'>");
        // }
        // function getJJ2(num){
        //     if(num==1){
        //         console.log('1*1=1')
        //     }else{
        //         getJJ2(num-1)
        //         let str=""
        //         for(let i=1;i<num+1;i++){
        //             str+=`${i}*${num}=${i*num} `
        //         } 
        //         console.log(str) 
        //     } 

        // }
        // getJJ()
        // getJJ2(9)
        // function Clock({ template }) {
  
        // let timer;

        // function render() {
        //     let date = new Date();

        //     let hours = date.getHours();
        //     if (hours < 10) hours = '0' + hours;

        //     let mins = date.getMinutes();
        //     if (mins < 10) mins = '0' + mins;

        //     let secs = date.getSeconds();
        //     if (secs < 10) secs = '0' + secs;

        //     let output = template
        //     .replace('h', hours)
        //     .replace('m', mins)
        //     .replace('s', secs);

        //     console.log(output);
        // }

        // this.stop = function() {
        //     clearInterval(timer);
        // };

        // this.start = function() {
        //     render();
        //     timer = setInterval(render, 1000);
        // };

        // }
        // class Clock {
        
        // constructor({template}){
        //     this.template=template
        //     this.stop = function() {
        //     clearInterval(this.timer);
        //   };

        //     this.start = function() {
        //     this.render();
        //     this.timer = setInterval(this.render, 1000);
        //   };
        // }
        
        // render=()=> {
        //     let date = new Date();

        //     let hours = date.getHours();
        //     if (hours < 10) hours = '0' + hours;

        //     let mins = date.getMinutes();
        //     if (mins < 10) mins = '0' + mins;

        //     let secs = date.getSeconds();
        //     if (secs < 10) secs = '0' + secs;

        //     let output = this.template
        //     .replace('h', hours)
        //     .replace('m', mins)
        //     .replace('s', secs);

        //     console.log(output);
        // }

        // }
        // class Clock{
            
        // constructor({template}){
        //     this.template=template
        // }

        // render() {
        //     let date = new Date();

        //     let hours = date.getHours();
        //     if (hours < 10) hours = '0' + hours;

        //     let mins = date.getMinutes();
        //     if (mins < 10) mins = '0' + mins;

        //     let secs = date.getSeconds();
        //     if (secs < 10) secs = '0' + secs;

        //     let output = this.template
        //     .replace('h', hours)
        //     .replace('m', mins)
        //     .replace('s', secs);

        //     console.log(output);
        // }

        // stop() {
        //     clearInterval(this.timer);
        // };

        // start(){
        //     this.render();
        //     this.timer = setInterval(()=>this.render(), 1000);//回调函数会改变this es6没有this
        //     // this.timer = setInterval(() => this.render(), 1000);
        // };

        // }
        // let clock = new Clock({template: 'h:m:s'});
        // clock.start();
        // function one() {
        //     setTimeout(() => {
        //         console.log(1)
        //         iterator.next()
        //     }, 1000);
        // }
        // function two() {
        //     setTimeout(() => {
        //         console.log(2)
        //         iterator.next()
        //     }, 2000);
        // }
        // function three() {
        //     setTimeout(() => {
        //         console.log(3)
        //         iterator.next()
        //     }, 3000);
        // }
        // function * gen () {
        //     yield one()
        //     yield two()
        //     yield three()
        //   }
        //   let iterator=gen()
        //   iterator.next()
        // class Phone{
        //     constructor(brand,price){
        //         this.brand=brand
        //         this.price=price
        //     }
        //     call(){
        //         console.log('play phone')
        //     }
        // }
        
        // class SmartPhone extends Phone{
        //     constructor(brand,price,color,size){
        //         super(brand,price)
        //         console.log(brand,price,color,size)
        //         this.color=color
        //         this.size=size
        //     }
        //     photo(){
        //         console.log('play photo')
        //     }
        //     playGame(){
        //         console.log('play Game')
        //     }
        // }
        // const xiaomi=new SmartPhone('xiaomi','black',799,'17.9cm')
        // console.log(xiaomi)
        // xiaomi.call()
        // xiaomi.photo()
        // xiaomi.playGame()
        // class Person{
        //     constructor(name,age){
        //         this.name=name
        //         this.age=age
        //     }
        //     func(){
        //         console.log(this.name,this.age)
        //     }
        // }
        // class Student extends Person{
        //     constructor(name,age,school){
        //         super(name,age)
        //         this.school=school
        //     }
        //     study(){
        //         console.log(this.school)
        //     }
        // }
        // let p1 =new Person('zangsan',14)
        // let p2 =new Student('lisi',16,'jialidun')
        // p1.func()
        // p2.study()
        // class Article {
        // constructor(title, date) {
        //     this.title = title;
        //     this.date = date;
        // }

        // static compare(articleA, articleB) {
        //     return articleA.date - articleB.date;
        // }
        // }

        // // 用法
        // let articles = [
        // new Article("HTML", new Date(2019, 1, 1)),
        // new Article("CSS", new Date(2019, 0, 1)),
        // new Article("JavaScript", new Date(2019, 11, 1))
        // ];

        // articles.sort(Article.compare);

        // alert( articles[0].title ); // CSS

        class Rabbit extends Object {
        // constructor(name) {
        //     this.name = name;
        // }
           constructor(name){
               super()
               this.name=name
           }
           
        }

        let rabbit = new Rabbit("Rab");
        console.log(rabbit)
        alert( rabbit.hasOwnProperty('name') ); // Error
</script>

</html>